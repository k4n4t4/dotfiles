#!/bin/sh
set -eu

#
# Useful functions
#

# check is number
is_number() {
  case "$1" in
    ( *[!0123456789]* )
      return 1
      ;;
    ( * )
      return 0
      ;;
  esac
}

# escape quotes
# * The return value is in RET
# e.g.
# qesc "ABC" -> RET="'ABC'"
# qesc "AB'C" -> RET="'AB'"'"'C'"
qesc() {
  RET="$1"
  set -- ""
  while : ; do
    case "$RET" in
      ( *"'"* )
        set -- "$1${RET%%"'"*}'\"'\"'"
        RET="${RET#*"'"}"
        ;;
      ( * )
        RET="'$1$RET'"
        break
        ;;
    esac
  done
}

# helper of opt_parser
opt_parser_get_arg_count() {
  RET="$1"
  eval "set -- $2"
  while [ $# -gt 0 ]; do
    case "$1" in ( "$RET:"?* )
      RET="${1#"$RET:"}"
      return 0
    esac
    shift
  done
  RET=0
  return 0
}

# option parser
# e.g.
# opt_parser --A:1 -- "$@"
# eval "set -- $RET"
# while [ $# -gt 0 ]; do
#   case "$1" in
#     ( -- )
#       shift 1
#       break
#       ;;
#     ( --A )
#       arg_of_A="$2"
#       shift 2
#       ;;
#     ( -a )
#       : a option
#       shift 1
#       ;;
#     ( -b )
#       : b option
#       shift 1
#       ;;
#     ( * )
#       error "Invalid Option: \"$1\""
#       return 1
#       ;;
#   esac
# done
opt_parser() {
  _option_has_arg=""
  while [ $# -gt 0 ]; do
    case "$1" in
      ( "--" )
        shift
        break
        ;;
      ( ?*":"?* )
        qesc "$1"
        _option_has_arg="$_option_has_arg $RET"
        shift
        ;;
      ( * )
        _variable_name="$1"
        shift
        ;;
    esac
  done
  _normal_args=""
  _option_args=""
  _scan_option=true
  while [ $# -gt 0 ]; do
    if $_scan_option; then
      case "$1" in ( "-"?* )
        case "$1" in
          ( "--" )
            _scan_option=false
            shift
            ;;
          ( "--"* | "-"? )
            case "$1" in ( "--"?*"="* )
              _opt_name="${1%%"="*}"
              _opt_val="${1#*"="}"
              shift
              set -- "$_opt_name" "$_opt_val" "$@"
              continue
            esac
            opt_parser_get_arg_count "$1" "$_option_has_arg"
            _arg_count="$RET"
            if [ $# -gt "$_arg_count" ]; then
              qesc "$1"
              _option_args="$_option_args $RET"
              shift
              while [ "$_arg_count" -gt 0 ]; do
                qesc "$1"
                _option_args="$_option_args $RET"
                shift
                _arg_count=$((_arg_count - 1))
              done
            else
              : error point
              shift
            fi
            ;;
          ( * )
            _multi_short_opt="${1#?}"
            while [ "$_multi_short_opt" != "" ]; do
              s="-${_multi_short_opt%"${_multi_short_opt#?}"*}"
              _multi_short_opt="${_multi_short_opt#?}"
              case "$s" in
                ( "--" ) : ;;
                ( * )
                  opt_parser_get_arg_count "$s" "$_option_has_arg"
                  _arg_count="$RET"
                  if [ "$_arg_count" -ne 0 ]; then
                    : error point
                  else
                    qesc "$s"
                    _option_args="$_option_args $RET"
                  fi
                  ;;
              esac
            done
            shift
            ;;
        esac
        continue
      esac
    fi
    qesc "$1"
    _normal_args="$_normal_args $RET"
    shift
  done
  _normal_args="${_normal_args#" "}"
  _option_args="${_option_args#" "}"
  RET="${_option_args} '--' ${_normal_args}"
  if [ "${_variable_name:-}" != "" ]; then
    eval "$_variable_name"'="$RET"'
  fi
}


ESC="$(printf "\033")"
LF='
'

get_todo_list() {
  todo_list=""
  while read -r line; do
    eval "set -- $line"

    qesc "$1"
    todo_line="$RET"
    qesc "$2"
    todo_line="$todo_line $RET"
    qesc "$3"
    todo_line="$todo_line $RET"
    qesc "$4"
    todo_line="$todo_line $RET"

    qesc "$todo_line"
    todo_list="$todo_list$RET "
  done < "$TODO_FILE"
  RET="$todo_list"
}


usage() {
  echo " [ Usage ]"
}

add() {
  opt_parser -p:1 --priority:1 -- "$@"
  eval "set -- $RET"
  while [ $# -gt 0 ]; do
    case "$1" in
      ( -- )
        shift 1
        break
        ;;
      ( -p | --priority )
        if is_number "$2"; then
          opt_priority="$2"
          shift 2
        else
          echo "\"$1\" is not number" >&2
          return 1
        fi
        ;;
      ( -c | --complete )
        opt_complete=true
        shift 1
        ;;
      ( * )
        echo "Invalid Option: \"$1\"" >&2
        return 1
        ;;
    esac
  done

  todo_priority=${opt_priority:-0}
  todo_complete=${opt_complete:-false}
  todo_date="$(date "+%y-%m-%d %H:%M:%S")"

  while [ $# -gt 0 ]; do
    qesc "$1"
    echo "'$todo_priority' '$todo_complete' '$todo_date' $RET" >> "$TODO_FILE"
    shift
  done
}

del() {
  opt_parser -- "$@"
  eval "set -- $RET"
  while [ $# -gt 0 ]; do
    case "$1" in
      ( -- )
        shift 1
        break
        ;;
      ( * )
        echo "Invalid Option: \"$1\"" >&2
        return 1
        ;;
    esac
  done
  if [ $# -ne 1 ]; then
    echo "Invalid arguments." >&2
    return 1
  fi
  if ! is_number "$1"; then
    echo "\"$1\" is not number." >&2
    return 1
  fi
  todo_del_index="$1"

  get_todo_list
  eval "set -- $RET"
  : > "$TODO_FILE"
  todo_index=0
  while [ $# -gt 0 ]; do
    if [ $todo_index -eq $todo_del_index ]; then
      shift
      todo_index=$((todo_index + 1))
      continue
    fi
    printf "%s\n" "$1" >> "$TODO_FILE"
    shift
    todo_index=$((todo_index + 1))
  done
}

move() {
  opt_parser -- "$@"
  eval "set -- $RET"
  while [ $# -gt 0 ]; do
    case "$1" in
      ( -- )
        shift 1
        break
        ;;
      ( * )
        echo "Invalid Option: \"$1\"" >&2
        return 1
        ;;
    esac
  done
  if [ $# -ne 2 ]; then
    echo "Invalid arguments." >&2
    return 1
  fi
  if ! is_number "$1"; then
    echo "\"$1\" is not number." >&2
    return 1
  fi
  if ! is_number "$2"; then
    echo "\"$2\" is not number." >&2
    return 1
  fi
  if [ $1 -eq $2 ]; then
    return 0
  fi
  todo_move_from_index=$1
  todo_move_to_index=$2

  get_todo_list
  eval "set -- $RET"

  if [ $todo_move_from_index -lt 0 ] || [ $((todo_move_from_index + 1)) -gt $# ]; then
    echo "Invalid number." >&2
    return 1
  fi
  if [ $todo_move_to_index -lt 0 ] || [ $((todo_move_to_index)) -gt $# ]; then
    echo "Invalid number." >&2
    return 1
  fi

  : > "$TODO_FILE"
  eval "todo_move_from_text=\"\${$((todo_move_from_index + 1))}\""
  todo_index=0
  while [ $# -gt 0 ]; do
    if [ $todo_index -eq $todo_move_to_index ]; then
      printf "%s\n" "$todo_move_from_text" >> "$TODO_FILE"
      printf "%s\n" "$1" >> "$TODO_FILE"
      shift
    else
      if [ $todo_index -eq $todo_move_from_index ]; then
        shift
      else
        printf "%s\n" "$1" >> "$TODO_FILE"
        shift
      fi
    fi
    todo_index=$((todo_index + 1))
  done
  if [ $todo_index -eq $todo_move_to_index ]; then
    printf "%s\n" "$todo_move_from_text" >> "$TODO_FILE"
  fi
}

complete() {
  opt_parser -- "$@"
  eval "set -- $RET"
  while [ $# -gt 0 ]; do
    case "$1" in
      ( -- )
        shift 1
        break
        ;;
      ( * )
        echo "Invalid Option: \"$1\"" >&2
        return 1
        ;;
    esac
  done
  if [ $# -ne 1 ]; then
    echo "Invalid arguments." >&2
    return 1
  fi
  if ! is_number "$1"; then
    echo "\"$1\" is not number." >&2
    return 1
  fi
  todo_complete_index=$1

  get_todo_list
  eval "set -- $RET"
  : > "$TODO_FILE"
  todo_index=0
  while [ $# -gt 0 ]; do
    env_func() {
      eval "set -- $1"

      qesc "$1"
      todo_line="$RET"

      if [ $todo_index -eq $todo_complete_index ]; then
        if $2; then
          todo_line="$todo_line 'false'"
        else
          todo_line="$todo_line 'true'"
        fi
      else
        qesc "$2"
        todo_line="$todo_line $RET"
      fi

      qesc "$3"
      todo_line="$todo_line $RET"
      qesc "$4"
      todo_line="$todo_line $RET"

      printf "%s\n" "$todo_line" >> "$TODO_FILE"
    }
    env_func "$1"
    shift
    todo_index=$((todo_index + 1))
  done
}

list() {
  opt_parser -- "$@"
  eval "set -- $RET"
  while [ $# -gt 0 ]; do
    case "$1" in
      ( -- )
        shift 1
        break
        ;;
      ( * )
        echo "Invalid Option: \"$1\"" >&2
        return 1
        ;;
    esac
  done

  get_todo_list
  eval "set -- $RET"
  todo_length=$#
  todo_digit=$((todo_length - 1))
  todo_length_digit=${#todo_digit}
  todo_index=0
  while [ $# -gt 0 ]; do
    env_func() {
      eval "set -- $1"
      if $2; then
        todo_complete_symbol="+"
      else
        todo_complete_symbol="-"
      fi
      todo_index_text="$todo_index"
      todo_index_digit=${#todo_index}
      todo_zero=$((todo_length_digit - todo_index_digit))
      while [ $todo_zero -gt 0 ]; do
        todo_index_text="0$todo_index_text"
        todo_zero=$((todo_zero - 1))
      done
      printf "%s\n" "$todo_index_text|$1|$todo_complete_symbol|$3| $4"
    }
    env_func "$1"
    shift
    todo_index=$((todo_index + 1))
  done
}


########################
#   Todo File Format   #
########################
#                      #
# >> '1' '2' '3' '4'   #
#                      #
# [1] priority: int    #
# [2] complete: bool   #
# [3] date: date       #
# [4] text: str        #
#                      #
########################
TODO_FILE="$HOME/.todo"

main() {
  [ $# -eq 0 ] && set -- list
  case "$1" in

    ( help )
      shift
      usage "$@"
      return $?
      ;;

    ( add | a )
      shift
      add "$@"
      return $?
      ;;

    ( del | d )
      shift
      del "$@"
      return $?
      ;;

    ( move | m )
      shift
      move "$@"
      return $?
      ;;

    ( complete | c )
      shift
      complete "$@"
      return $?
      ;;

    ( list | l )
      shift
      list "$@"
      return $?
      ;;

    ( * )
      echo "${ESC}[31mInvalid Sub Command: \"$1\"${ESC}[m" >&2
      usage
      return 1
      ;;

  esac
}

main "$@"
